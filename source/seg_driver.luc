/*
   A module to drive the seven segment displays.
   This module reads from an 8x8 RAM and drives the output accordingly.
   
   Requires counter component
   Requires simple_dual_ram component
   Requires seg_rom components
   
   To use: 
   Connect clk to system clock.
   Connect rst to a reset source.
   
   mem_data to regfile read data port
   mem_addr to regfile read address port
   done to game logic (or wherever)
   
   data, dclk, srst, sclk to appropriate i/o pins
*/

module seg_driver #(
    BASE_DIV = 6 : BASE_DIV >= 0  
  )(
    input clk,  // clock (Rising edge -> 1 bit sent out on any one of the data lines)
    input rst,  // reset (Assert to reset the state and start writing out again)
    
    input mem_data[4], // 4 bit wide tile
    output mem_addr[6], // address 56 tiles (64 in memory)
    output done, // finished writing memory to output 
    
    output data[8], // data lines
    output dclk[8], // data clock lines
    output srst[8], // storage register reset lines
    output sclk[8] // storage clock lines
    
  ) {
  
  // Internal signals for data, dclk, sclk to be demuxed later
  sig int_data;
  sig int_dclk;
  sig int_sclk;
  
  // Division for byte counter
  const BYTE_DIV = BASE_DIV + 4;
  
  // This is the counter that controls bit output.
  // It has 6 bits of division so its frequency is 3.125MHz
  // The counter is 4 bits long. The bits can be broken down like this:
  // Bit 0: SCK 
  // Bit 3-1: Bit position in data word
  counter ctr_bit (
    #SIZE(4), #DIV(BASE_DIV), #UP(1),
     .clk(clk), .rst(rst)
  );
  
  // This is wired in the always block later
  sig ctr_data_bit[3];
    
  // This is the counter that determines which column we are on.
  // The top is the max number of real display columns (zero-based)
  // It has 10 bits of division to align with the end of bit counter
  // Counts up from 0 1 2 3 4 5 6 0 1 ...
  counter ctr_column (
    #SIZE(3), #DIV(BYTE_DIV), #TOP(6), #UP(1),
    .clk(clk), .rst(rst)
  );
  
  // This is the counter that determines which row we are on.
  // The top is the max number of rows (zero-based)
  // 13 bits of division to line up with end of counter column
  counter ctr_row (
    #SIZE(3), #DIV(0), #TOP(7), #UP(1),
    .clk(~ctr_column.value[2]), .rst(rst)
  );
  
  // Currently active row
  sig active_row[3];
  
  // Currently active sclk row (one behind active row)
  sig active_sclk_row[3];
  
  // State of the driver.
  fsm driver_state (#INIT(FIRST_WRITE), .clk(clk), .rst(rst)) = {
    FIRST_WRITE, ABOUT_TO_FINISH, PULSE_LAST_SCLK, DONE
  };
      
  // Connect rom address to RAM data
  seg_rom rom (.address(mem_data));

  always {
    // Reset all shift registers when component is reset 
    // Inversion required as srst is active low
    srst = 8x{~rst};
    
    // Tie low first, modified later in fsm case 
    done = 0;
    
    // External outputs tied low first
    data = 8x{0};
    dclk = 8x{0};
    sclk = 8x{0};

    // Internal sclk is simply the MSB of column counter.
    // Sclk for the finished row goes high halfway during the next row
    int_sclk = ~|ctr_column.value;
    
    // Internal dclk is the LSB of bit counter
    int_dclk = ctr_bit.value[0];

    // Bit selector of data byte are the remaining bits of bit counter
    ctr_data_bit = ctr_bit.value[3:1];
    
    active_row = ctr_row.value;
    active_sclk_row = active_row - 1;
    
    // Which data bit to send out now?
    int_data = rom.pattern[ctr_data_bit];
    
    // memory address to read follows row and col value
    mem_addr = c{ctr_row.value, 6-ctr_column.value};
    
    // Connect internal signals to real outputs.
    // Did I need to fix these to 8x{0} earlier?
    data[active_row] = int_data;
    dclk[active_row] = int_dclk;
    sclk[active_sclk_row] = int_sclk;
    
    // driver_state FSM for done output 
    case(driver_state.q) {
      driver_state.FIRST_WRITE:
        done = 0;
        // About to finish...
        if (ctr_row.value == 3d7) {
          driver_state.d = driver_state.ABOUT_TO_FINISH;
        }
      driver_state.ABOUT_TO_FINISH:
        done = 0;
        if (ctr_row.value == 3d0) {
          int_sclk = 0;
          driver_state.d = driver_state.PULSE_LAST_SCLK;
        }
      driver_state.PULSE_LAST_SCLK:
        int_sclk = 1;
        done = 0;
        driver_state.d = driver_state.DONE;
      driver_state.DONE:
        int_sclk = ~|ctr_column.value;
        done = 1;
        // Don't leave this state until reset
    }
  }
}
