module mojo_top (
    input clk,              // 50MHz clock
    input rst_n,            // reset button (active low)
    output led [8],         // 8 user controllable LEDs
    input cclk,             // configuration clock, AVR ready when high
    output spi_miso,        // AVR SPI MISO
    input spi_ss,           // AVR SPI Slave Select
    input spi_mosi,         // AVR SPI MOSI
    input spi_sck,          // AVR SPI Clock
    output spi_channel [4], // AVR general purpose pins (used by default to select ADC channel)
    input avr_tx,           // AVR TX (FPGA RX)
    output avr_rx,          // AVR RX (FPGA TX)
    input avr_rx_busy  ,     // AVR RX buffer full
    
    input row_button[8],  //button lines
    output col_button[7],  //button lines
    input flag[1],
    
    output data[8], // data lines
    output dclk[8], // data clock lines
    output srst[8], // storage register reset lines
    output sclk[8] // storage clock lines 

  ) {
  
  sig rst;                  // reset signal
  
  sig btn_rst;
  sig mf_logic_rst;
  sig winning_condition_rst;
  sig advance_map_rst;
  
  sig mf_logic_clk;
  sig winning_condition_clk;
  sig advance_map_clk;
  
  sig alu_16_a[16];
  sig alu_16_b[16];
  sig alu_16_alu[16];
  sig alufn[6]; 
  
  sig mine_map;

  sig mf_reg_wen;
  sig flagged;
  sig btn_clk;
  
  sig btn_pressed;
  sig win_con_done;
  sig win_con_win;
  
  
  const SHOW_WIN = {
    4h9, 4h9, 4h9, 4h9, 4h9, 4h9, 4h9, 4h0,
    4h9, 4h9, 4h9, 4h9, 4h9, 4h9, 4h9, 4h0,
    4h9, 4h9, 4h9, 4h9, 4h9, 4h9, 4h9, 4h0,
    4h9, 4h9, 4h9, 4h9, 4h9, 4h9, 4h9, 4h0,
    4h9, 4h9, 4h9, 4h9, 4h9, 4h9, 4h9, 4h0,
    4h9, 4h9, 4h9, 4h9, 4h9, 4h9, 4h9, 4h0,
    4h9, 4h9, 4h9, 4h9, 4h9, 4h9, 4h9, 4h0,
    4h9, 4h9, 4h9, 4h9, 4h9, 4h9, 4h9, 4h0
  };
  
  const SHOW_LOSE = {
    4hF, 4hF, 4hF, 4hF, 4hF, 4hF, 4hF, 4h0,
    4hF, 4hF, 4hF, 4hF, 4hF, 4hF, 4hF, 4h0,
    4hF, 4hF, 4hF, 4hF, 4hF, 4hF, 4hF, 4h0,
    4hF, 4hF, 4hF, 4hF, 4hF, 4hF, 4hF, 4h0,
    4hF, 4hF, 4hF, 4hF, 4hF, 4hF, 4hF, 4h0,
    4hF, 4hF, 4hF, 4hF, 4hF, 4hF, 4hF, 4h0,
    4hF, 4hF, 4hF, 4hF, 4hF, 4hF, 4hF, 4h0,
    4hF, 4hF, 4hF, 4hF, 4hF, 4hF, 4hF, 4h0
  };


  
  .clk(clk) {
    // The reset conditioner is used to synchronize the reset signal to the FPGA
    // clock. This ensures the entire FPGA comes out of reset at the same time.
    reset_conditioner reset_cond;
    
    dff ctr64[$clog2(64)];
    
    .rst(rst){
      reg_file display_reg_file (#SIZE(64), #WIDTH(4));
      seg_driver seg_driver;
      

      fsm pulser(#INIT(HIGH)) = {HIGH, LOW};
      fsm game(#INIT(POLL)) = {IDLE, POLL, CALCULATE, GOAL_CHECK, LOST, WIN, COUNT64_LOST, COUNT64_WIN};
      
      counter mem_write_counter (
        #SIZE($clog2(64)), #DIV(2), #TOP(63), #UP(1)
      );


    }
    
  }
  .clk(btn_clk){
  
    button_conditioner button_conditioner;
    
    .rst(btn_rst){
    
    button_decoder button_decoder;
    
    }
  }

  .clk(mf_logic_clk){
    .rst(mf_logic_rst){
  
    minefield_logic minefield_logic;
    reg_file minefield_state_register (#SIZE(64), #WIDTH(2));
    }
  }
  
  .clk(winning_condition_clk){
    .rst(winning_condition_rst){
  
    winning_condition winning_condition;
    }
  }
  
  .clk(advance_map_clk){
    .rst(advance_map_rst){
  
    counter ctr (#SIZE(2), #TOP(2), #UP(1)); 
      
    }
  }
    
 
  alu16 alu16;
  minefield_rom minefield_rom;

  
  
  
  
  always {
    reset_cond.in = ~rst_n; // input raw inverted reset signal
    rst = reset_cond.out;   // conditioned reset
    
    led = 8h00;             // turn LEDs off
    spi_miso = bz;          // not using SPI
    spi_channel = bzzzz;    // not using flags
    avr_rx = bz;            // not using serial port
    
    mf_logic_clk = 0;
    btn_clk = 0;
    winning_condition_clk = 0;
   
    
    
    // Instantitaion
    
    //advance mine
    advance_map_clk = 0;
    advance_map_rst = 0;
    
    //winning_condition
    winning_condition.mfstateval = minefield_state_register.rdata;
    winning_condition.mfromval = minefield_rom.mine_map[ctr.value];
   
    win_con_done = winning_condition.done;
    win_con_win = winning_condition.win;

    
    //button_conditioner
    button_conditioner.in = flag;
    flagged = button_conditioner.out;
    
    
    //Display Register File
    display_reg_file.raddr = seg_driver.mem_addr;
    display_reg_file.wen = minefield_logic.wen;
    display_reg_file.wdata = minefield_logic.wdata;
    display_reg_file.waddr = button_decoder.addr;
    
    //Game Logic
    alu_16_a = minefield_logic.alua;
    alu_16_b = minefield_logic.alub;
    alu_16_alu = alu16.alu;
    alufn = minefield_logic.alufn;
    mf_reg_wen = minefield_logic.mfstatewe;
    minefield_logic.badrs = button_decoder.addr;
    minefield_logic.mfromval = minefield_state_register.rdata;
    minefield_logic.mfstateval = minefield_state_register.rdata;
    minefield_logic.flagbtn = flag;
    
    // 7-segment LED driver
    data = seg_driver.data;
    dclk = seg_driver.dclk;
    srst = seg_driver.srst;
    sclk = seg_driver.sclk;
    seg_driver.mem_data = display_reg_file.rdata;
    
    
    // Button Decoder
    button_decoder.row_input = row_button;
    col_button = button_decoder.col_drive;
    btn_pressed = button_decoder.button_pressed;
    
    // ALU
    alu16.a = alu_16_a;
    alu16.b = alu_16_b;
    alu16.alufn = alufn;
    alu_16_alu = alu16.alu;
    
    // Minefield ROM
    mine_map = minefield_rom.mine_map[ctr.value];
    minefield_rom.address = minefield_logic.mfromadrs;
 
        
    // Minefield State Register
    minefield_state_register.raddr = minefield_logic.mfstatereg;
    minefield_state_register.waddr = minefield_logic.mfstatereg;
    minefield_state_register.wen = minefield_logic.mfstatewe;
    minefield_state_register.wdata = minefield_logic.mf_state_reg_wd;
    
    
    
    
    ///////////FSM///////////
    
    case (pulser.q){
    
      pulser.HIGH:
      
        rst = 1;

        pulser.d = pulser.LOW;
    
      pulser.LOW:
      
        rst = 0;
        

    }
    
    
    case (game.q){
    
      game.IDLE :
      
        mf_logic_clk = clk;
        mf_logic_rst = 1;
        btn_clk = clk;
        btn_rst =1;
        
        
        pulser.d = pulser.HIGH;

      
        if (btn_pressed){
        
          mf_logic_clk = 0;
          btn_clk = 0;
        
          game.d = game.POLL;
        }
      
      game.POLL:
        
        mf_logic_clk = clk;
        mf_logic_rst = 1;
        btn_clk = clk;
        btn_rst =1;
        
        
        pulser.d = pulser.HIGH;

      
        if (btn_pressed){
        
          mf_logic_clk = 0;
          btn_clk = 0;
        
          game.d = game.CALCULATE;
        }
        
      game.CALCULATE:
      
        mf_logic_clk = clk;
        mf_logic_rst = 1;
        btn_clk = clk;
        btn_rst = 1;
        
        pulser.d = pulser.HIGH;

        
        if (minefield_logic.done){
        
          mf_logic_clk = 0;
          btn_clk = 0;
          
          game.d = game.GOAL_CHECK;
        } else {
        
          if (minefield_logic.lost){
        
            mf_logic_clk = 0;
            btn_clk = 0;
            
            game.d = game.LOST;
            
          }
        }
      
      game.GOAL_CHECK:
      
        winning_condition_clk = clk;
        winning_condition_rst = 1;
        pulser.d = pulser.HIGH;
        
        if (win_con_done){
        
          winning_condition_clk = 0;
          
          game.d = game.POLL; 
          
          } else {
        
          if ((ctr.value < b11) && win_con_win){
          
            winning_condition_clk = 0;
            
            advance_map_clk = pulser.q;
            advance_map_rst = 1;
                      
            game.d = game.POLL;
            } else {
          
              if ((ctr.value == b11) && win_con_win){
            
                game.d = game.WIN;
              }
              
          }
       }
        
      game.LOST:
      
        ctr64.d = ctr64.q + 1;
        
module mojo_top (
    input clk,              // 50MHz clock
    input rst_n,            // reset button (active low)
    output led [8],         // 8 user controllable LEDs
    input cclk,             // configuration clock, AVR ready when high
    output spi_miso,        // AVR SPI MISO
    input spi_ss,           // AVR SPI Slave Select
    input spi_mosi,         // AVR SPI MOSI
    input spi_sck,          // AVR SPI Clock
    output spi_channel [4], // AVR general purpose pins (used by default to select ADC channel)
    input avr_tx,           // AVR TX (FPGA RX)
    output avr_rx,          // AVR RX (FPGA TX)
    input avr_rx_busy  ,     // AVR RX buffer full
    
    input row_button[8],  //button lines
    output col_button[7],  //button lines
    input flag[1],
    
    output data[8], // data lines
    output dclk[8], // data clock lines
    output srst[8], // storage register reset lines
    output sclk[8] // storage clock lines 

  ) {
  
  sig rst;                  // reset signal
  
  sig btn_rst;
  sig mf_logic_rst;
  sig winning_condition_rst;
  sig advance_map_rst;
  
  sig mf_logic_clk;
  sig winning_condition_clk;
  sig advance_map_clk;
  
  sig alu_16_a[16];
  sig alu_16_b[16];
  sig alu_16_alu[16];
  sig alufn[6]; 
  
  sig mine_map;

  sig mf_reg_wen;
  sig flagged;
  sig btn_clk;
  
  sig btn_pressed;
  sig win_con_done;
  sig win_con_win;
  
  
  const SHOW_WIN = {
    4h9, 4h9, 4h9, 4h9, 4h9, 4h9, 4h9, 4h0,
    4h9, 4h9, 4h9, 4h9, 4h9, 4h9, 4h9, 4h0,
    4h9, 4h9, 4h9, 4h9, 4h9, 4h9, 4h9, 4h0,
    4h9, 4h9, 4h9, 4h9, 4h9, 4h9, 4h9, 4h0,
    4h9, 4h9, 4h9, 4h9, 4h9, 4h9, 4h9, 4h0,
    4h9, 4h9, 4h9, 4h9, 4h9, 4h9, 4h9, 4h0,
    4h9, 4h9, 4h9, 4h9, 4h9, 4h9, 4h9, 4h0,
    4h9, 4h9, 4h9, 4h9, 4h9, 4h9, 4h9, 4h0
  };
  
  const SHOW_LOSE = {
    4hF, 4hF, 4hF, 4hF, 4hF, 4hF, 4hF, 4h0,
    4hF, 4hF, 4hF, 4hF, 4hF, 4hF, 4hF, 4h0,
    4hF, 4hF, 4hF, 4hF, 4hF, 4hF, 4hF, 4h0,
    4hF, 4hF, 4hF, 4hF, 4hF, 4hF, 4hF, 4h0,
    4hF, 4hF, 4hF, 4hF, 4hF, 4hF, 4hF, 4h0,
    4hF, 4hF, 4hF, 4hF, 4hF, 4hF, 4hF, 4h0,
    4hF, 4hF, 4hF, 4hF, 4hF, 4hF, 4hF, 4h0,
    4hF, 4hF, 4hF, 4hF, 4hF, 4hF, 4hF, 4h0
  };


  
  .clk(clk) {
    // The reset conditioner is used to synchronize the reset signal to the FPGA
    // clock. This ensures the entire FPGA comes out of reset at the same time.
    reset_conditioner reset_cond;
    
    dff ctr64[$clog2(64)];
    
    .rst(rst){
      reg_file display_reg_file (#SIZE(64), #WIDTH(4));
      seg_driver seg_driver;
      

      fsm pulser(#INIT(HIGH)) = {HIGH, LOW};
      fsm game(#INIT(POLL)) = {IDLE, POLL, CALCULATE, GOAL_CHECK, LOST, WIN, COUNT64_LOST, COUNT64_WIN};
      
      counter mem_write_counter (
        #SIZE($clog2(64)), #DIV(2), #TOP(63), #UP(1)
      );


    }
    
  }
  .clk(btn_clk){
  
    button_conditioner button_conditioner;
    
    .rst(btn_rst){
    
    button_decoder button_decoder;
    
    }
  }

  .clk(mf_logic_clk){
    .rst(mf_logic_rst){
  
    minefield_logic minefield_logic;
    reg_file minefield_state_register (#SIZE(64), #WIDTH(2));
    }
  }
  
  .clk(winning_condition_clk){
    .rst(winning_condition_rst){
  
    winning_condition winning_condition;
    }
  }
  
  .clk(advance_map_clk){
    .rst(advance_map_rst){
  
    counter ctr (#SIZE(2), #TOP(2), #UP(1)); 
      
    }
  }
    
 
  alu16 alu16;
  minefield_rom minefield_rom;

  
  
  
  
  always {
    reset_cond.in = ~rst_n; // input raw inverted reset signal
    rst = reset_cond.out;   // conditioned reset
    
    led = 8h00;             // turn LEDs off
    spi_miso = bz;          // not using SPI
    spi_channel = bzzzz;    // not using flags
    avr_rx = bz;            // not using serial port
    
    mf_logic_clk = 0;
    btn_clk = 0;
    winning_condition_clk = 0;
   
    
    
    // Instantitaion
    
    //advance mine
    advance_map_clk = 0;
    advance_map_rst = 0;
    
    //winning_condition
    winning_condition.mfstateval = minefield_state_register.rdata;
    winning_condition.mfromval = minefield_rom.mine_map[ctr.value];
   
    win_con_done = winning_condition.done;
    win_con_win = winning_condition.win;

    
    //button_conditioner
    button_conditioner.in = flag;
    flagged = button_conditioner.out;
    
    
    //Display Register File
    display_reg_file.raddr = seg_driver.mem_addr;
    display_reg_file.wen = minefield_logic.wen;
    display_reg_file.wdata = minefield_logic.wdata;
    display_reg_file.waddr = button_decoder.addr;
    
    //Game Logic
    alu_16_a = minefield_logic.alua;
    alu_16_b = minefield_logic.alub;
    alu_16_alu = alu16.alu;
    alufn = minefield_logic.alufn;
    mf_reg_wen = minefield_logic.mfstatewe;
    minefield_logic.badrs = button_decoder.addr;
    minefield_logic.mfromval = minefield_state_register.rdata;
    minefield_logic.mfstateval = minefield_state_register.rdata;
    minefield_logic.flagbtn = flag;
    
    // 7-segment LED driver
    data = seg_driver.data;
    dclk = seg_driver.dclk;
    srst = seg_driver.srst;
    sclk = seg_driver.sclk;
    seg_driver.mem_data = display_reg_file.rdata;
    
    
    // Button Decoder
    button_decoder.row_input = row_button;
    col_button = button_decoder.col_drive;
    btn_pressed = button_decoder.button_pressed;
    
    // ALU
    alu16.a = alu_16_a;
    alu16.b = alu_16_b;
    alu16.alufn = alufn;
    alu_16_alu = alu16.alu;
    
    // Minefield ROM
    mine_map = minefield_rom.mine_map[ctr.value];
    minefield_rom.address = minefield_logic.mfromadrs;
 
        
    // Minefield State Register
    minefield_state_register.raddr = minefield_logic.mfstatereg;
    minefield_state_register.waddr = minefield_logic.mfstatereg;
    minefield_state_register.wen = minefield_logic.mfstatewe;
    minefield_state_register.wdata = minefield_logic.mf_state_reg_wd;
    
    
    
    
    ///////////FSM///////////
    
    case (pulser.q){
    
      pulser.HIGH:
      
        rst = 1;

        pulser.d = pulser.LOW;
    
      pulser.LOW:
      
        rst = 0;
        

    }
    
    
    case (game.q){
    
      game.IDLE :
      
        mf_logic_clk = clk;
        mf_logic_rst = 1;
        btn_clk = clk;
        btn_rst =1;
        
        
        pulser.d = pulser.HIGH;

      
        if (btn_pressed){
        
          mf_logic_clk = 0;
          btn_clk = 0;
        
          game.d = game.POLL;
        }
      
      game.POLL:
        
        mf_logic_clk = clk;
        mf_logic_rst = 1;
        btn_clk = clk;
        btn_rst =1;
        
        
        pulser.d = pulser.HIGH;

      
        if (btn_pressed){
        
          mf_logic_clk = 0;
          btn_clk = 0;
        
          game.d = game.CALCULATE;
        }
        
      game.CALCULATE:
      
        mf_logic_clk = clk;
        mf_logic_rst = 1;
        btn_clk = clk;
        btn_rst = 1;
        
        pulser.d = pulser.HIGH;

        
        if (minefield_logic.done){
        
          mf_logic_clk = 0;
          btn_clk = 0;
          
          game.d = game.GOAL_CHECK;
        } else {
        
          if (minefield_logic.lost){
        
            mf_logic_clk = 0;
            btn_clk = 0;
            
            game.d = game.LOST;
            
          }
        }
      
      game.GOAL_CHECK:
      
        winning_condition_clk = clk;
        winning_condition_rst = 1;
        pulser.d = pulser.HIGH;
        
        if (win_con_done){
        
          winning_condition_clk = 0;
          
          game.d = game.POLL; 
          
          } else {
        
          if ((ctr.value < b11) && win_con_win){
          
            winning_condition_clk = 0;
            
            advance_map_clk = pulser.q;
            advance_map_rst = 1;
                      
            game.d = game.POLL;
            } else {
          
              if ((ctr.value == b11) && win_con_win){
            
                game.d = game.WIN;
              }
              
          }
       }
        
      game.LOST:
      
        ctr64.d = ctr64.q + 1;
        
        mf_logic_clk = clk;
        mf_logic_rst = 1;
        
        
        display_reg_file.wdata = SHOW_LOSE[mem_write_counter.value[5:1]];
        display_reg_file.wen = clk;
        display_reg_file.waddr = mem_write_counter.value[5:1];
        
        seg_driver.mem_data = display_reg_file.rdata;
        display_reg_file.raddr = seg_driver.mem_addr;
        
        data = seg_driver.data;
        dclk = seg_driver.dclk;
        sclk = seg_driver.sclk;
        srst = seg_driver.srst;
        
        game.d = game.COUNT64_LOST;
        
        
      game.COUNT64_LOST:
        
        if (ctr64.q == 64){
        
          game.d = game.IDLE;
          } else {
        
          game.d = game.LOST;
          
          }
        
      game.WIN:
      
        ctr64.d = ctr64.q + 1;
        
        mf_logic_clk = clk;
        mf_logic_rst = 1;
        
        
        display_reg_file.wdata = SHOW_WIN[mem_write_counter.value[5:1]];
        display_reg_file.wen = clk;
        display_reg_file.waddr = mem_write_counter.value[5:1];
        
        seg_driver.mem_data = display_reg_file.rdata;
        display_reg_file.raddr = seg_driver.mem_addr;
        
        data = seg_driver.data;
        dclk = seg_driver.dclk;
        sclk = seg_driver.sclk;
        srst = seg_driver.srst;
        
        
        
        game.d = game.COUNT64_LOST;
        
        
      game.COUNT64_WIN:
        
        if (ctr64.q == 64){
        
          game.d = game.IDLE;
          } else {
        
          game.d = game.WIN;
          
          }
     }     
   }
 }
